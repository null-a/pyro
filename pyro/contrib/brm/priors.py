from collections import namedtuple
from pprint import pprint as pp

import pandas as pd

from pyro.contrib.brm.formula import Formula, _1
from pyro.contrib.brm.design import dfmetadata, designmatrix_metadata

Node = namedtuple('Node', 'name prior children')

def leaf(name):
    return Node(name, None, [])

# This is similar to brms `set_prior`. (e.g. `set_prior('<prior>',
# coef='x1')` is similar to `Prior(['x1'], '<prior>)`.) By specifying
# paths (rather than class/group/coef) we're diverging from brms, but
# the hope is that a brms-like interface can be put in front of this.

# TODO: Something better than strings for specifying prior.

Prior = namedtuple('Prior', 'path prior')

def select(node, path):
    if len(path) == 0:
        return node
    else:
        name = path[0]
        selected_node = next((n for n in node.children if n.name == name), None)
        if selected_node is None:
            raise Exception('Invalid path')
        return select(selected_node, path[1:])

def edit(node, path, f):
    if len(path) == 0:
        # We're at the node to be edited. (i.e. Empty path picks out
        # the root node.)
        newnode = f(node)
        assert type(newnode) == Node
        return newnode
    else:
        # Recursively edit the appropriate child. (Or children, if
        # names are duplicated.)
        name = path[0]
        children = [edit(n, path[1:], f) if n.name == name else n
                    for n in node.children]
        return Node(node.name, node.prior, children)


# TODO: This ought to warn/error when an element of `priors` has a
# path that doesn't correspond to a node in the tree.

def desc_prior(population_meta, group_metas, priors):
    # Column names of population design matrix. (As generated by
    # `designmatrix_metadata`.)
    assert type(population_meta) == PopulationMeta
    assert type(group_metas) == list
    assert all(type(gm) == GroupMeta for gm in group_metas)
    assert type(priors) == list
    assert all(type(p) == Prior for p in priors)
    ptree = Node('b', None, [leaf(name) for name in population_meta.coefs])
    gtrees = [Node(gm.name, None, [leaf(name) for name in gm.coefs]) for gm in group_metas]
    # TODO: Add "class" for correlation matrices.
    # TODO: Figure out how to incorporate priors on the response
    # distribution.
    tree = Node('root', None, [ptree, Node('sd', None, gtrees)])
    for p in priors:
        tree = edit(tree, p.path, lambda n: Node(n.name, p.prior, n.children))
    return tree


# TODO: dedup
def join(lists):
    return sum(lists, [])

def tree2list(node, path=[]):
    return [('/'.join(path), node.prior)] + join(tree2list(n, path+[n.name]) for n in node.children)

# An example function making use of the tree. Here we compute the
# prior to use for each coefficient.
def foo(node, path=[], default=None):
    default = node.prior if not node.prior is None else default
    if len(node.children) == 0:
        # Leaf.
        return [('/'.join(path), default)]
    else:
        # Internal node.
        return join(foo(n, path + [n.name], default) for n in node.children)

# TODO: These (or similar) ought to be defined in design.py, and
# returned by a function that takes a formula and a df desc., and
# returns population/group design matrix metadata.
PopulationMeta = namedtuple('PopulationMeta', 'coefs')
GroupMeta = namedtuple('GroupMeta', 'name coefs')

def main():
    pp(foo(desc_prior(
        # population
        PopulationMeta(['intercept', 'x1', 'x2']),
        # groups
        [
            GroupMeta('grp1', ['intercept']),
            GroupMeta('grp2', ['intercept', 'z']),
            GroupMeta('grp3', ['intercept'])
        ],
        # priors
        [
            Prior(['b'], 'b'),
            Prior(['sd'], 'a'),
            Prior(['sd', 'grp2'], 'c'),
            Prior(['sd', 'grp2', 'z'], 'd'),
        ])))

    # [('b/intercept',       'b'),
    #  ('b/x1',              'b'),
    #  ('b/x2',              'b'),
    #  ('sd/grp1/intercept', 'a'),
    #  ('sd/grp2/intercept', 'c'),
    #  ('sd/grp2/z',         'd'),
    #  ('sd/grp3/intercept', 'a')]

if __name__ == '__main__':
    main()
