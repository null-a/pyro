from collections import namedtuple

# The back end interface and its types are something like:

# posterior.samples :: bs
# posterior.get_param :: (bs, string) -> ps
# posterior.location :: dict string ps -> ps
# posterior.to_numpy :: ps -> ndarray
# backend.from_numpy :: ndarray -> ps
# model.inv_link_fn :: ps -> ps
# model.expected_response_fn :: (ps, ps, ...) -> ps

# Where the back end specific types bs and ps are:

# bs is the type of a collection (not necessarily iterable) of
# samples. (e.g. For Pyro this is a list of traces.)
#
# ps is the type of a collection (not necessarily iterable) of sampled
# parameters (e.g. In Pyro this is a torch array, where first
# dimension ranges over samples.)
#

# `to_numpy`: This provides a back-end specific method for turning
# parameter samples (as returned by `get_param`) into a numpy array.


# `get_param`: It's expected that `get_param` should support all
# parameter names returned by `parameter_names(model)` where `model`
# is the `ModelDesc` from which samples were drawn.

# `from_numpy`: This gives the back-end an opportunity to convert
# model data from numpy (as generated by design.py) into its preferred
# representation (ps).


# For now, assume that each back end provides a single inference algorithm.
Backend = namedtuple('Backend', 'name gen nuts svi from_numpy to_numpy')

# Map `from_numpy` over a dict of numpy arrays, (As produced by e.g.
# `makedata`.)
def data_from_numpy(backend, data):
    assert type(backend) == Backend
    assert type(data) == dict
    return {k: backend.from_numpy(arr) for k, arr in data.items()}

# We could have a class that wraps a (function, code) pair, making the
# code available via a code property and the function available via
# __call__. `Model` could also be callable. Too cute?
Model = namedtuple('Model', [
    'fn', 'code',
    'inv_link_fn', 'inv_link_code',
    'expected_response_fn', 'expected_response_code',
])

def apply_default_hmc_args(iter, warmup):
    iter = 10 if iter is None else iter
    warmup = iter // 2 if warmup is None else warmup
    return iter, warmup
